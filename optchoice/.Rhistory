hello()
library(optchoice)
?ggplot2
library(optchoice)
hello()
createlegend()
?ggplot2
library(optchoice)
createlegend()
library(optchoice)
outcomeplot("Delta0.01Check", 10)
outcomeplot(filename = "Delta0.01Check", nsim = 10)
wd()
setwd
cd()
getwd()
outcomeplot(filename = "Delta0.01Check", nsim = 10)
library(optchoice)
outcomeplot(filename = "Delta0.01Check", nsim = 10)
getwd()
outcomeplot(filename = "Delta0.01Check.csv", nsim = 10)
library(optchoice)
outcomeplot(filename = "Delta0.01Check.csv", nsim = 10)
outcomeplot(filename = "Delta0.01Check.csv", nsim = 10, title = "Delta = 0.01")
library(optchoice)
plot1 <- outcomeplot(filename = "Delta0.01Check.csv", nsim = 10)
plot2 <- outcomeplot(filename = "Delta0.05Check.csv", nsim = 10)
plot3 <- outcomeplot(filename = "Delta0.2Check.csv", nsim = 10)
arrangeGrob(plot1,plot2,plot3,ncol=3,nrow=2)
plots <- arrangeGrob(plot1,plot2,plot3,ncol=3,nrow=2)
grid.draw(plots)
plot1 <- plot1 + ggtitle("Delta = 0.01")
plot2 <- plot2 + ggtitle("Delta = 0.05")
plot3 <- plot3 + ggtitle("Delta = 0.2")
plots <- arrangeGrob(plot1,plot2,plot3,ncol=3,nrow=2)
grid.draw(plots)
makeplots(filename = "test.csv", heatmap = "heatmap.csv")
makeplots(filename = "test.csv", heatmap = "heatmap.csv", everyntimesteps = 50)
checkspeciation(heatmap = "heatmap.csv", filename = "test.csv")
check <- checkspeciation(heatmap = "heatmap.csv", filename = "test.csv")
library(optchoice)
makeplots(filename = "test.csv", heatmap = "heatmap.csv", everyntimesteps = 50)
outcomeplot(filename = "Delta0.05Check.csv", nsim = 10, title = "Delta = 0.05")
outcomeplot(filename = "Delta0.01Check.csv", nsim = 10, title = "Delta = 0.01")
library(optchoice)
makeplots(filename = "test.csv", heatmap = "heatmap.csv", everyntimesteps = 20)
outcomeplot(filename = "Delta0.01Check.csv", nsim = 10, title = "Delta = 0.01")
outcomeplot(filename = "Delta0.05Check.csv", nsim = 10, title = "Delta = 0.05")
outcomeplot(filename = "Delta0.2Check.csv", nsim = 10, title = "Delta = 0.2")
plot1 <- outcomeplot(filename = "Delta0.01Check.csv", nsim = 10, title = "Delta = 0.01")
plot2 <- outcomeplot(filename = "Delta0.05Check.csv", nsim = 10, title = "Delta = 0.05")
plot3 <- outcomeplot(filename = "Delta0.2Check.csv", nsim = 10, title = "Delta = 0.2")
plots <- arrangeGrob(plot1, plot2, plot3, ncol = 3, nrow = 2)
grid.draw(plots)
grid.draw(plots)
library(optchoice)
makeplots(filename = "test.csv", heatmap = "heatmap.csv", everyntimesteps = 25)
heatmap <- "heatmap.csv"
d <- read.csv(heatmap, header = TRUE) #Create data frame for heatmap of csv file
d2 <- as.data.frame(matrix(0, 2 / stepsize, (length(d[, 1]) - 1) / everyntimesteps + 1)) #Create data frame of 0s with 2/stepsize rows and as many columns as the number of time steps
for (i in 1:length(d[, 1])) { #Each timestep
if ((i - 1) %% everyntimesteps == 0) { #Only use every everyntimesteps time step
k <- length(d2[, 1]) #Set k to highest step
for (j in 2:length(d[1, ])) { #Each individual
while (d[i, j] < (k - 1) * stepsize - 1) { #As long as the X value is smaller than lower bound of current step
k <- k - 1 #Set k to the next step below the current step
}
d2[k, (i - 1) / everyntimesteps + 1] <- d2[k, (i - 1) / everyntimesteps + 1] + 1 #Add one to respective step
}
print(d[i,1])
}
}
times <- rep(seq(0, (length(d2) - 1) * everyntimesteps, d[1 + everyntimesteps, 1] - d[1, 1]), each = 2/stepsize) #Create a list of the time points
X <- seq(-1 + stepsize / 2, 1 - stepsize / 2, stepsize) #Create a list of the middle between steps
d2 <- cbind(X, d2) #Add step list to front of data frame
d2 <- melt(d2, id.vars = "X") #Reshape data frame to make it able to be used by ggplot
d2$time <- times #Add new column to data frame with values of time points
colnames(d2)[colnames(d2)=="value"] <- "count" #Rename value column to count
specialist <- ggplot(d2, aes(time, X)) + geom_raster(aes(fill = count), interpolate = TRUE) + theme(legend.position = "top")
library(optchoice)
stepsize <- 0.05
everyntimesteps <- 25
d <- read.csv(heatmap, header = TRUE) #Create data frame for heatmap of csv file
d2 <- as.data.frame(matrix(0, 2 / stepsize, (length(d[, 1]) - 1) / everyntimesteps + 1)) #Create data frame of 0s with 2/stepsize rows and as many columns as the number of time steps
for (i in 1:length(d[, 1])) { #Each timestep
if ((i - 1) %% everyntimesteps == 0) { #Only use every everyntimesteps time step
k <- length(d2[, 1]) #Set k to highest step
for (j in 2:length(d[1, ])) { #Each individual
while (d[i, j] < (k - 1) * stepsize - 1) { #As long as the X value is smaller than lower bound of current step
k <- k - 1 #Set k to the next step below the current step
}
d2[k, (i - 1) / everyntimesteps + 1] <- d2[k, (i - 1) / everyntimesteps + 1] + 1 #Add one to respective step
}
print(d[i,1])
}
}
times <- rep(seq(0, (length(d2) - 1) * everyntimesteps, d[1 + everyntimesteps, 1] - d[1, 1]), each = 2/stepsize) #Create a list of the time points
X <- seq(-1 + stepsize / 2, 1 - stepsize / 2, stepsize) #Create a list of the middle between steps
d2 <- cbind(X, d2) #Add step list to front of data frame
d2 <- melt(d2, id.vars = "X") #Reshape data frame to make it able to be used by ggplot
d2$time <- times #Add new column to data frame with values of time points
colnames(d2)[colnames(d2)=="value"] <- "count" #Rename value column to count
specialist <- ggplot(d2, aes(time, X)) + geom_raster(aes(fill = count), interpolate = TRUE) + theme(legend.position = "top")
d <- read.csv(heatmap, header = TRUE) #Create data frame for heatmap of csv file
d2 <- as.data.frame(matrix(0, 2 / stepsize, (length(d[, 1]) - 1) / everyntimesteps + 1)) #Create data frame of 0s with 2/stepsize rows and as many columns as the number of time steps
for (i in 1:length(d[, 1])) { #Each timestep
if ((i - 1) %% everyntimesteps == 0) { #Only use every everyntimesteps time step
k <- length(d2[, 1]) #Set k to highest step
for (j in 2:length(d[1, ])) { #Each individual
while (d[i, j] < (k - 1) * stepsize - 1) { #As long as the X value is smaller than lower bound of current step
k <- k - 1 #Set k to the next step below the current step
}
d2[k, (i - 1) / everyntimesteps + 1] <- d2[k, (i - 1) / everyntimesteps + 1] + 1 #Add one to respective step
}
print(d[i,1])
}
}
times <- rep(seq(0, (length(d2) - 1) * everyntimesteps, d[1 + everyntimesteps, 1] - d[1, 1]), each = 2/stepsize) #Create a list of the time points
X <- seq(-1 + stepsize / 2, 1 - stepsize / 2, stepsize) #Create a list of the middle between steps
d2 <- cbind(X, d2) #Add step list to front of data frame
d2 <- melt(d2, id.vars = "X") #Reshape data frame to make it able to be used by ggplot
d2$time <- times #Add new column to data frame with values of time points
colnames(d2)[colnames(d2)=="value"] <- "count" #Rename value column to count
generalist <- ggplot(d2, aes(time, X)) + geom_raster(aes(fill = count), interpolate = TRUE) + theme(legend.position = "top")
d <- read.csv(heatmap, header = TRUE) #Create data frame for heatmap of csv file
d2 <- as.data.frame(matrix(0, 2 / stepsize, (length(d[, 1]) - 1) / everyntimesteps + 1)) #Create data frame of 0s with 2/stepsize rows and as many columns as the number of time steps
for (i in 1:length(d[, 1])) { #Each timestep
if ((i - 1) %% everyntimesteps == 0) { #Only use every everyntimesteps time step
k <- length(d2[, 1]) #Set k to highest step
for (j in 2:length(d[1, ])) { #Each individual
while (d[i, j] < (k - 1) * stepsize - 1) { #As long as the X value is smaller than lower bound of current step
k <- k - 1 #Set k to the next step below the current step
}
d2[k, (i - 1) / everyntimesteps + 1] <- d2[k, (i - 1) / everyntimesteps + 1] + 1 #Add one to respective step
}
print(d[i,1])
}
}
times <- rep(seq(0, (length(d2) - 1) * everyntimesteps, d[1 + everyntimesteps, 1] - d[1, 1]), each = 2/stepsize) #Create a list of the time points
X <- seq(-1 + stepsize / 2, 1 - stepsize / 2, stepsize) #Create a list of the middle between steps
d2 <- cbind(X, d2) #Add step list to front of data frame
d2 <- melt(d2, id.vars = "X") #Reshape data frame to make it able to be used by ggplot
d2$time <- times #Add new column to data frame with values of time points
colnames(d2)[colnames(d2)=="value"] <- "count" #Rename value column to count
speciation <- ggplot(d2, aes(time, X)) + geom_raster(aes(fill = count), interpolate = TRUE) + theme(legend.position = "top")
specialist <- specialist + ggtitle("Specialist")
generalist <- generalist + ggtitle("Generalist")
speciation <- speciation + ggtitle("2 Species")
plots <- grid.arrange(generalist, speciation, specialist, ncol = 3)
plots <- grid.arrange(generalist, speciation, specialist, ncol = 3, nrow = 2)
library(optchoice)
makeplots("test.csv", "heatmap.csv")
makeplots("test.csv", "heatmap.csv", everyntimesteps = 25)
heatmap <- "heatmap.csv"
filename <- "test.csv"
threshold <- 400
output <- NA
d <- read.csv(heatmap, header = TRUE)
d2 <- as.data.frame(matrix(ncol = 2, nrow = length(d[,1])))
d3 <- as.data.frame(matrix(ncol = 2, nrow = length(d[,1])-9))
vec <- vector()
for (i in 1:length(d[,1])) {
x <- t(d[i,-1])
fit <- Mclust(x, G = 1, model = "V", verbose = FALSE, prior = priorControl())
fit2 <- Mclust(x, G = 2, model = "V", verbose = FALSE, prior = priorControl())
d2[i,1] <- d[i,1]
d2[i,2] <- fit2$loglik - fit$loglik
if (i > 9) {
average <- 0
for (j in (i-9):i) {
average <- average + d2[j,2]
}
average <- average / 10
d3[i-9,1] <- d2[i-9,1]
d3[i-9,2] <- average
if (average > threshold) { #If speciation value is high enough to assume 2 species are present
if (length(vec) == 0) { #If this is first time 2 species are present
vec[1] <- d[i,1] #Set first value of vector to current generation
vec[2] <- d[i,1] #Set second value of vector to current generation (this will change to last consecutive generation with 2 species present)
}
else if (i == length(d[,1])) { #If it is the last generation of the simulation
if (d[i,1] - vec[length(vec)] < 50) { #If speciation hasn't gone on for long enough
if (length(vec) == 2) { #If this is the only speciation event
vec <- vector() #Clear vector
}
else { #If this is not the only speciation event
vec <- vec[1:(length(vec)-2)] #Only clear starting point of this speciation event
}
}
}
else if (d[i,1] - vec[length(vec)] > 1) { #If last generation did not have 2 species present
vec[length(vec) + 1] <- d[i,1] #Set next value of vector to current generation
vec[length(vec) + 1] <- d[i,1] #Set next value of vector to current generation
}
else { #If last generation also had 2 species present
vec[length(vec)] <- d[i,1] #Change last value of vector to current generation
}
}
else {
if (length(vec) > 0) { #If speciation has occured
if (d[i,1] - vec[length(vec)] == 1) { #If speciation occured last generation
if (vec[length(vec)] - vec[length(vec)-1] < 50) { #If speciation didn't exist for long enough
if (length(vec) == 2) { #If this is the only speciation event
vec <- vector() #Clear vector
}
else { #If there are other speciation events
vec <- vec[1:(length(vec)-2)] #Only clear this speciation event
}
}
}
}
}
}
print(d[i,1])
}
d <- read.csv(heatmap, header = TRUE)
d2 <- as.data.frame(matrix(ncol = 2, nrow = length(d[,1])))
d3 <- as.data.frame(matrix(ncol = 2, nrow = length(d[,1])-9))
vec <- vector()
for (i in 1:(length(d[,1])-1)) {
x <- t(d[i,-1])
fit <- Mclust(x, G = 1, model = "V", verbose = FALSE, prior = priorControl())
fit2 <- Mclust(x, G = 2, model = "V", verbose = FALSE, prior = priorControl())
d2[i,1] <- d[i,1]
d2[i,2] <- fit2$loglik - fit$loglik
if (i > 9) {
average <- 0
for (j in (i-9):i) {
average <- average + d2[j,2]
}
average <- average / 10
d3[i-9,1] <- d2[i-9,1]
d3[i-9,2] <- average
if (average > threshold) { #If speciation value is high enough to assume 2 species are present
if (length(vec) == 0) { #If this is first time 2 species are present
vec[1] <- d[i,1] #Set first value of vector to current generation
vec[2] <- d[i,1] #Set second value of vector to current generation (this will change to last consecutive generation with 2 species present)
}
else if (i == length(d[,1])) { #If it is the last generation of the simulation
if (d[i,1] - vec[length(vec)] < 50) { #If speciation hasn't gone on for long enough
if (length(vec) == 2) { #If this is the only speciation event
vec <- vector() #Clear vector
}
else { #If this is not the only speciation event
vec <- vec[1:(length(vec)-2)] #Only clear starting point of this speciation event
}
}
}
else if (d[i,1] - vec[length(vec)] > 1) { #If last generation did not have 2 species present
vec[length(vec) + 1] <- d[i,1] #Set next value of vector to current generation
vec[length(vec) + 1] <- d[i,1] #Set next value of vector to current generation
}
else { #If last generation also had 2 species present
vec[length(vec)] <- d[i,1] #Change last value of vector to current generation
}
}
else {
if (length(vec) > 0) { #If speciation has occured
if (d[i,1] - vec[length(vec)] == 1) { #If speciation occured last generation
if (vec[length(vec)] - vec[length(vec)-1] < 50) { #If speciation didn't exist for long enough
if (length(vec) == 2) { #If this is the only speciation event
vec <- vector() #Clear vector
}
else { #If there are other speciation events
vec <- vec[1:(length(vec)-2)] #Only clear this speciation event
}
}
}
}
}
}
print(d[i,1])
}
View(d2)
i <- 3001
average <- 0
for (j in (i-9):i) {
average <- average + d2[j,2]
}
average <- average / 10
d3[i-9,1] <- d2[i-9,1]
d3[i-9,2] <- average
average <- 0
for (j in (i-9):i) {
average <- average + d2[j,2]
}
x <- t(d[i,-1])
fit <- Mclust(x, G = 1, model = "V", verbose = FALSE, prior = priorControl())
fit2 <- Mclust(x, G = 2, model = "V", verbose = FALSE, prior = priorControl())
d2[i,1] <- d[i,1]
d2[i,2] <- fit2$loglik - fit$loglik
average <- 0
for (j in (i-9):i) {
average <- average + d2[j,2]
}
average <- average / 10
d3[i-9,1] <- d2[i-9,1]
d3[i-9,2] <- average
View(d2)
View(d3)
d[i,1] - vec[length(vec)]
d[i,1] - vec[length(vec)-1]
d[i,1] - vec[length(vec)]
library(optchoice)
checkspeciation("heatmap.csv", "test.csv")
library(optchoice)
checkspeciation("heatmap.csv", "test.csv")
