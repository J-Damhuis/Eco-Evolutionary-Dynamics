//---------------------------------------------------------------------------

#include <vector>
#include <math.h>
#include <fstream>
#include <stdlib.h>
#include "random.h"
#include "distributions.h"
#pragma hdrstop

using namespace std;
//---------------------------------------------------------------------------
//member variables of host
struct host
{
	int numencountersv;	//number of encounters with vitripennis
	int numencountersg;	//number of encounters with giraulti
	int numeggsv;		//number of eggs laid in this host by vitripennis
	int numeggsg;		//number of eggs laid in this host by giraulti
	double eggsurvivalv;	//survival probability of eggs laid by vitripennis
	double eggsurvivalg;	//survival probability of eggs laid by giraulti
};

int numgenerations;	//number of generations per simulation run
int numruns;		//number of simulation runs

int initialhosts;	//initial host abundance
int initialv;		//initial abundance of vitripennis
int initialg;		//initial abundance of giraulti
double av;		//vitripennis attack rate
double ag;		//giraulti attack rate
double cv;		//vitripennis fecundity
double cg;		//giraulti fecundity
double correlation;	//correlation between distributions of vitripennis and giraulti

double lambda;	//intrinsic growth rate of hosts
double d;		//death rate of hosts
double k;		//aggregation parameter
double maxc;		//within-host carrying capacity
double wg;		//within-host advantage for giraulti (1 = the same fitness for both species)

int populationsize_v; //abundance of vitripennis
int populationsize_g; //abundance of giraulti

int numsurviving_v;	  //number of simulation runs where only vitripennis survives
int numsurviving_g;	  //number of simulation runs where only giraulti survives
int numsurviving_both; //number of simulation runs where both survive (coexistence)

//---------------------------------------------------------------------------
void getparameters(ifstream &infile)
{
	//read parameter values from file
	char *pEnd;
	string stuff;
	int line = 0;
	while (!infile.eof())
	{
		getline(infile, stuff);
		if (line == 0)
			numruns = strtol(stuff.c_str(), &pEnd, 10);
		if (line == 1)
			numgenerations = strtol(stuff.c_str(), &pEnd, 10);
		if (line == 2)
			av = strtod(stuff.c_str(), &pEnd);
		if (line == 3)
			ag = strtod(stuff.c_str(), &pEnd);
		if (line == 4)
			lambda = strtod(stuff.c_str(), &pEnd);
		if (line == 5)
			k = strtod(stuff.c_str(), &pEnd);
		if (line == 6)
			d = strtod(stuff.c_str(), &pEnd); 
		if (line == 7)
			initialhosts = strtol(stuff.c_str(), &pEnd, 10);
		if (line == 8)
			initialv = strtol(stuff.c_str(), &pEnd, 10);
		if (line == 9)
			initialg = strtol(stuff.c_str(), &pEnd, 10);
		if (line == 10)
			cv = strtod(stuff.c_str(), &pEnd);
		if (line == 11)
			cg = strtod(stuff.c_str(), &pEnd);
		if (line == 12)
			maxc = strtod(stuff.c_str(), &pEnd);
		if (line == 13)
			correlation = strtod(stuff.c_str(), &pEnd);
		if (line == 14)
			wg = strtod(stuff.c_str(), &pEnd);
		line++;
	}
}
//---------------------------------------------------------------------------
void updatehost(host &x)
{
	//reset variables to zero at the beginning of each generation
	x.numencountersv = 0;
	x.numencountersg = 0;
	x.numeggsv = 0;
	x.numeggsg = 0;
}
//---------------------------------------------------------------------------
void initialize (vector<host> &h)
{
	//set host abundance to initial value; reset other values by update
	h.resize(initialhosts);
	for (int i = 0; i < h.size(); i++)
		updatehost(h[i]);
}
//---------------------------------------------------------------------------
int calculateeggs (double f)
{
	//number of eggs laid during parasitism
	//draw number from poisson distribution with mean = fecundity
	return poisson(f);
}
//---------------------------------------------------------------------------
int calculateoffspring(int numeggs, double survival)
{
	//go over all eggs laid; each survives with a probability given by survival
	//if survival >= 1, all survive until adulthood
	int x = 0;
	for (int i = 0; i < numeggs; i++)
		if (survival > Uniform())
			x++;
	return x;
}
//---------------------------------------------------------------------------
void parasitize (vector<host> &h)
{
	//calculate number of offspring generated by parasitism
	//first, calculate number of eggs laid by both species in each host
	int numv = 0;
	int numg = 0;
	for (int i = 0; i < h.size(); i++)
	{
		for (int j = 0; j < h[i].numencountersv; j++)		
			h[i].numeggsv += calculateeggs(cv);
		for (int j = 0; j < h[i].numencountersg; j++)		
			h[i].numeggsg += calculateeggs(cg);
	}

	//survival in larval stage is dependent on how many eggs were laid in total, as well as within-host carrying capacity
	//if wg > 1 and multiparasitism has occurred, eggs laid by giraulti have a higher survival probability
	for (int i = 0; i < h.size(); i++)
	{
		h[i].eggsurvivalv = maxc / (double(h[i].numeggsv) + wg * double(h[i].numeggsg));
		h[i].eggsurvivalg = wg * maxc / (double(h[i].numeggsv) + wg * double(h[i].numeggsg));
		numv += calculateoffspring(h[i].numeggsv, h[i].eggsurvivalv);
		numg += calculateoffspring(h[i].numeggsg, h[i].eggsurvivalg);	
	}
	//populations in next generation are equal to number of emerging parasitoids
	populationsize_v = numv;
	populationsize_g = numg;
}
//---------------------------------------------------------------------------
void hostreproduction(vector<host> &h)
{
	//calculate next generation of hosts: all hosts escaping parasitism, multiplied by lambda, with some density dependence
	int totalsurviving = 0;
	for (int i = 0; i < h.size(); i++)
		if (h[i].numencountersv == 0 && h[i].numencountersg == 0)
			totalsurviving++;
	int nextgen = totalsurviving * lambda * exp (-d * double(totalsurviving));
	
	//resize vector, reset values for hosts
	h.resize(nextgen);
	for (int i = 0; i < nextgen; i++)
		updatehost(h[i]);	
}
//---------------------------------------------------------------------------
void distributeencounters(vector<host> &h)
{
	//determine for each host how many encounters it has with both parasitoid species
	//number drawn from a bivariate negative binomial distribution with clumping parameter k and average encounters for both species as means
	double averageencountersv = populationsize_v * av;
	double averageencountersg = populationsize_g * ag;
	for (int i = 0; i < h.size(); i++)
		distributenegbinom(k, correlation, averageencountersv, averageencountersg, h[i].numencountersv, h[i].numencountersg);
}
//---------------------------------------------------------------------------
void maketimeseries(vector< vector<double> > &output, vector<host> &h, int run, int generation)
{
	//store abundances of hosts and parasitoids every 10 generations
	if (run == 0)
		output[0][generation] = generation * 10;
	output[run * 3 + 1][generation] = h.size();
	output[run * 3 + 2][generation] = populationsize_v;
	output[run * 3 + 3][generation] = populationsize_g;
}
//---------------------------------------------------------------------------

#pragma argsused
int main(int argc, char* argv[])
{
	//read parameter values from input file
	string infilename = argv[1];
	ifstream infile;
	do
		infile.open(infilename.c_str());
	while (infile.is_open() == false);
	getparameters(infile);
	infile.close();
	 
	//create output files; write random seed to output files
	string outfilename1 = argv[2];
	string outfilename2 = argv[3];
	ofstream outfile1 (outfilename1.c_str());
	ofstream outfile2(outfilename2.c_str());
	int seed = atoi(argv[4]);
	SetSeed(seed);

	//initialize simulation: create array of hosts, output
	vector<host> hosts (initialhosts);	
	vector< vector<double> > output_timeseries(numruns * 3 + 1, vector<double> (numgenerations / 10, 0));
	numsurviving_v = 0;
	numsurviving_g = 0;
	numsurviving_both = 0;

	for (int m = 0; m < numruns; m++)
	{
		//initialize simulation run: reset population sizes to initial values
		initialize(hosts);
		populationsize_v = initialv;
		populationsize_g = initialg;
		
		//actual simulation
		for (int i = 0; i < numgenerations; i++)
		{
			if (i % 10 == 0)
				maketimeseries(output_timeseries, hosts, m, i / 10); //store abundance timeseries every 10 generations
			distributeencounters(hosts); //determine for each host how many encounters with vitripennis and giraulti it will have
			parasitize(hosts);		 //do the encounters; calculate number of surviving parasitoids of both species
			hostreproduction(hosts);	 //reproduction of hosts
		}
		//write abundances of hosts and both parasitoid species to file
		outfile2 << m + 1 << "\t" << hosts.size() << "\t" << populationsize_v << "\t" << populationsize_g << endl;
		
		//score whether there was coexistence at the end of the simulation
		if (populationsize_v > 0 && populationsize_g > 0)
			numsurviving_both++;
		if (populationsize_v > 0 && populationsize_g == 0)
			numsurviving_v++;
		if (populationsize_v == 0 && populationsize_g > 0)
			numsurviving_g++;
	}
	//write number of runs in which there was coexistence or no coexistence to file
	outfile2 << endl << numsurviving_v << "\t" << numsurviving_g << "\t" << numsurviving_both;
	
	//write abundance timesries to file
	outfile1 << "time\t";
	for (int i = 0; i < numruns; i++)
		outfile1 << "hosts\tv\tg\t";
	outfile1 << endl;
	for (int i = 0; i < numgenerations / 10; i++)
	{
		for (int j = 0; j < output_timeseries.size(); j++)
			outfile1 << output_timeseries[j][i] << "\t";
		outfile1 << endl;
	}
        
	return 0;
}
//---------------------------------------------------------------------------
